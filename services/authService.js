/***********************************************************
 *  Import all app services, models and utils as needed.
 **********************************************************/
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const logger = require("../logger/appLogger");
const User = require("../models/userModels");
const { apiStatus } = require("../services/httpResponseService");
const { TOKEN_LIFE, SALT_ROUND, APP_SECRET, PER_PAGE } = require("../config");

class authService {
  async checkEmailExist(email, boolean_type = true) {
    /**
     * It checks if the email exists in the database
     * @param email - The email address to check
     * @param [boolean_type=true] - If true, it will return true or false. If false, it will return the
     * user object.
     */
    try {
      const is_exist = await User.findOneByEmail(email);
      return boolean_type ? (is_exist.length ? true : false) : is_exist;
    } catch (error) {
      logger.error(error?.message);
      return error?.message;
    }
  }

  /**
   * It takes a password as an argument, generates a salt, and then hashes the password with the salt
   * @param password - The password to be hashed.
   * @returns The hashed password.
   */
  async hashPassword(password) {
    try {
      /* Generate a salt */
      const salt = await bcrypt.genSalt(Number(SALT_ROUND));

      /* Hash password */
      return await bcrypt.hash(password, salt);
    } catch (error) {
      logger.error(error?.message);
      return error?.message;
    }
  }

  /**
   * It takes a password and a hash, and returns true if the password matches the hash, and false if it
   * doesn't
   * @param password - The password that the user entered.
   * @param hash - The hash that was generated by the bcrypt.hash() function.
   * @returns A promise that resolves to a boolean.
   */
  async compareHashPassword(password, hash) {
    try {
      return await bcrypt.compare(password, hash);
    } catch (error) {
      logger.error(error?.message);
      return error?.message;
    }
  }

  /**
   * It takes in a data object, signs it with the secret key, and returns a token that expires in the
   * amount of time specified in the TOKEN_LIFE variable
   * @param data - The data to be signed.
   * @returns A token that is signed with the APP_SECRET and expires in TOKEN_LIFE.
   */
  async signToken(data, expiresIn = TOKEN_LIFE) {
    try {
      return await jwt.sign(data, APP_SECRET, { expiresIn });
    } catch (error) {
      logger.error(error?.message);
      return error?.message;
    }
  }

  /**
   * The verifyToken function takes a token as an argument and returns the decoded token
   * @param token - The token to verify.
   * @returns The decoded token.
   */
  async verifyToken(token) {
    try {
      return await jwt.verify(token, APP_SECRET);
    } catch (error) {
      logger.error(error?.message);
      return error?.message;
    }
  }

  async getCurrentUserId(requestHeaders) {
    try {
      const bearerToken = requestHeaders["authorization"]?.split(" ")[1];
      const verified_token = await this.verifyToken(bearerToken);
      return verified_token.user_id;
    } catch (error) {
      logger.error(error?.message);
      return error?.message;
    }
  }

  /**
   * It takes in a user object, signs a token with the user's id and email, and returns an object with
   * the user's full name, email, image, and token
   * @param user_data - The user data object that was returned from the database.
   * @returns A signed token
   */
  async generateSignedAuthPayload(user_data) {
    try {
      const token = await this.signToken({
        user_id: user_data._id,
        email: user_data.email,
        role: user_data?.role,
      });

      return {
        fullname: `${user_data?.firstName} ${user_data?.lastName}`,
        email: user_data?.email,
        picture: user_data?.picture?.url ? user_data?.picture : null,
        role: user_data?.role,
        token,
      };
    } catch (error) {
      logger.error(error);
      return error?.message;
    }
  }

  /**
   * It checks if the email exists in the database, if it does, it checks if the password matches the
   * hash password in the database, if it does, it returns a signed JWT token, if it doesn't, it returns
   * an error
   * @param email - The email address of the user.
   * @param password - The password that the user entered.
   * @returns An object with either an error or data property.
   */
  async validateUserSignIn(email, password, next) {
    try {
      let email_exist = await this.checkEmailExist(email, false);

      if (email_exist.length) {
        if (await this.compareHashPassword(password, email_exist[0].password))
          return this.generateSignedAuthPayload(email_exist[0]);
        else return this.sendResponse("User password is not correct", next);
      } else return this.sendResponse("User email does not exist", next);
    } catch (error) {
      logger.error(error);
      this.sendResponse("An error while checking email", next, "internal");
    }
  }

  /**
   * It returns an object with the user's full name, email, profile picture, role, and the date the user
   * was created
   * @param userdata - The user object that is returned from the database.
   * @returns An object with the following properties:
   *   fullname: `${userdata?.firstName} ${userdata?.lastName}`,
   *   email: userdata?.email,
   *   picture: userdata?.picture,
   *   role: userdata?.role,
   *   createdAt: userdata?.createdAt,
   */
  renderUserPayload(userdata) {
    return {
      id: userdata._id,
      fullname: `${userdata?.firstName} ${userdata?.lastName}`,
      email: userdata?.email,
      picture: userdata?.picture?.url ? userdata?.picture : null,
      role: userdata?.role,
      createdAt: userdata?.createdAt,
    };
  }

  renderPaginatedPayload(data, { total, page }) {
    return {
      data,
      pagination: {
        total,
        page: +page,
        per_page: PER_PAGE,
        pages: Math.ceil(total / PER_PAGE),
      },
    };
  }

  /**
   * It sends a response to the client.
   * @param response_message - The message that will be sent to the user.
   * @param next - The next object
   * @param status - Api error response status
   * @returns A boolean value.
   */
  sendResponse(response_message, next, status = "unauthorized") {
    next(apiStatus[status](response_message));
    return false;
  }
}

module.exports = new authService();
